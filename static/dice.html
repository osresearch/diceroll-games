<!DOCTYPE html>
<html>
<head>
<title>Dice Rolling Demo</title>

<!-- HTML Meta Tags -->
<meta name="description" content="Multi-party cryptographic dice demo">

<!-- Facebook Meta Tags -->
<meta property="og:url" content="https://echo.v.st/">
<meta property="og:type" content="website">
<meta property="og:title" content="Multi-party chat demo">
<meta property="og:description" content="Websocket based chat room demo">
<meta property="og:image" content="https://echo.v.st/header.jpg">

<!-- Twitter Meta Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:domain" content="echo.v.st">
<meta property="twitter:url" content="https://echo.v.st/">
<meta name="twitter:title" content="Multi-party chat demo">
<meta name="twitter:description" content="Websocket based chat room demo">
<meta name="twitter:image" content="https://echo.v.st/header.jpg">

<!-- This is heavily inspired by https://socket.io/get-started/chat -->


<script
	src="https://cdn.socket.io/4.4.0/socket.io.min.js"
	integrity="sha384-1fOn6VtTq3PWwfsOrk45LnYcGosJwzMHv+Xh/Jx5303FVOXzEnw0EpLv30mtjmlj"
	crossorigin="anonymous"
></script>
<script src="sha256.js" ></script>

<style>
body  {
	background: black;
	color: #00ff00;
	font-family: mono;
}
.message-private { color: #ccc; }
.message-public { color: #0f0; }
.message-server { color: red; }
.sender-server { color: red; }
.sender-self { color: blue; }

</style>
</head>
<body>
<ul>
<li><button onclick="roll_commit(sock,0)">Roll!</button><span id="die-0"></span>
<li><button onclick="roll_commit(sock,1)">Roll!</button><span id="die-1"></span>
</ul>

<div id="log"></div>
</body>
<script>
function randomBigInt(bytes=32)
{
        let a = new Uint8Array(bytes);
        window.crypto.getRandomValues(a);
	return arrayToBigInt(a);
}

/*
 * Convert a byte array in MSB first order into a BigInt 
 */
function arrayToBigInt(a)
{
	let x = 0n;
	for(let y of a)
		x = (x << 8n) | BigInt(y);
        return x;
}

/*
 * Convert a BigInt to a byte array of length l in MSB first order.
 */
function arrayFromBigInt(m,l=32)
{
	let r = [];

	m = BigInt(m); // just in case

	for(let i = 1 ; i <= l ; i++)
	{
		r[l - i] = Number(m & 0xFFn);
		m >>= 8n;
	}

	if (m != 0n)
		console.log("m too big for l", m, l, r);

	return r;
}

/*
 * Hash a bigint, returning a bigint
 */
function sha256BigInt(x)
{
	return arrayToBigInt(sha256.sha256(arrayFromBigInt(x, 32)));
}
</script>

<script>
const server = document.location.origin;
const sock = io.connect(server);
if (!document.location.hash)
{
	let rand_room = randomBigInt(16).toString(36);

	console.log("generating random room", rand_room);
	document.location.hash = ''
		+ rand_room.substr(0,4)
		+ '-'
		+ rand_room.substr(4,4)
		+ '-'
		+ rand_room.substr(8,4)
		+ '-'
		+ rand_room.substr(12,4);
}

let room = document.location.hash;
let peers = {};
let rolls = {};

let die = [
	[ "1", "2", "3", "4", "5", "6" ],
	[ "1", "2", "3", "4", "5", "6", "7", "8" ],
];

function log_append(src, msg, msg_class="message")
{
	const log = document.getElementById("log");
	const e = document.createElement('p');
	const s = document.createElement('span');
	s.classList.add("sender");
	if (src == server)
		s.classList.add("sender-server");
	if (src == sock.id)
		s.classList.add("sender-self");
	s.innerText = src;
	e.appendChild(s);

	e.appendChild(document.createTextNode(" "));

	const m = document.createElement('span');
	m.classList.add(msg_class);
	m.innerText = msg;

	e.appendChild(m);
	log.appendChild(e);
}


/*
 * These are the system level ones that the server sends to us
 */
// called when a connection to the server is established
sock.on('connect', () => {
	// reset our peer list, cancel any die rolls in process
	peers = {};
	rolls = {};

	// join the room in the URL
	console.log(server, "RECONNECTED");
	log_append(server, 'Reconnected', 'message-server');
	sock.emit('room', room);
});

// server sends this message when a new room is joined
// to inform us of the other members
sock.on('members', (room, members) => {
	console.log(room + " members", members);
	log_append(server, 'joined ' + room + ' ' + members.length + ' members', 'message-server');

	// track the peers, including ourselves
	peers = {};
	peers[sock.id] = 1;

	for(let member of members)
	{
		peers[member] = 1;
		log_append(server, '+ ' + member, 'message-public');
	}

});

// called when a new peer joins the room
// which resets any rolls in process
sock.on('connected', (src) => {
	console.log(src, "new room member");
	log_append(server, '+ ' + src, 'message-public');

	rolls = {};
	peers[src] = 1;
});

// called when a peer leaves the room
// which resets any rolls in process
sock.on('disconnected', (src) => {
	console.log(src, "room member left");
	log_append(server, '- ' + src, 'message-public');

	rolls = {};

	if (src in peers)
		delete peers[src];
});


/*
 * These are the ones that we define for our dice client
 *
 * A peer can propose a set of dice (N sets of K images)
 *
 * A peer can start a roll for a dice by saying which die and a seed,
 * all peers will generate a random value and publish the hash of
 * the value. Once they have received hashes from all the other peers
 * in the room, they will publish the value.
 *
 * If this is a private roll, the initial peer can add all of the
 * revealed values, plus their own secret one and the seed, and
 * take it modulo the K for that die to learn the roll.
 *
 * When they are ready to reveal, they publish their value and the
 * everyone can compute the same result.
 *
 * Cheaters can't publish fake values, since they have already committed
 * the value.  They can't collude since they can't control the honest
 * player's value.
 * 
 */

// start a dice roll or respond to one
function roll_commit(sock, which=0, tag=randomBigInt())
{
	const tag_str = tag.toString(16);
	const short_tag = tag_str.substr(0,16);

	if (!(tag_str in rolls))
	{
		log_append(sock.id, short_tag + " NEW ROLL");
		rolls[tag_str] = {}
	}

	const my_value = randomBigInt(32);
	const my_hash = sha256BigInt(my_value);
	const my_roll = {
		hash: my_hash,
		value: my_value,
		which: which,
	};

	rolls[tag_str][sock.id] = my_roll;
	const hash_str = my_hash.toString(16);
	log_append(sock.id, short_tag + " hashed " + hash_str, 'message-public');

	sock.emit('commit', {
		"tag": tag_str,
		"which": which,
		"hash": hash_str,
	});
}

// called when another peer has initiated a dice roll or
// is responding to a dice roll by another peer.
sock.on('commit', (src,msg) => {
	console.log("commit", src, msg);

	if (!(src in peers))
	{
		log_append(src, "not in peer group?" + msg, 'message-server');
		return;
	}

	if (!("tag" in msg && "which" in msg && "hash" in msg))
	{
		log_append(src, "bad message" + msg, 'message-server');
		return;
	}

	const tag = msg.tag.toString();
	const short_tag = tag.substr(0,16);
	const which = msg.which;
	const hash = msg.hash;

	if (!(which in die))
	{
		log_append(src, short_tag + " no such die " + which, 'message-server');
		return;
	}

	if (!(tag in rolls))
	{
		// first time we've seen this tag, so let's
		// create the bookkeeping for it
		log_append(src, short_tag + " NEW ROLL");
		rolls[tag] = {}

		// and add our roll and commitment to it,
		// plus send the reply to the room
		roll_commit(sock, which, tag);
	}

	const roll = rolls[tag];

	// if this src has already done this roll, then
	// they are cheating (or the server has duped us)
	if (src in roll)
	{
		console.log("duplicate?", src, msg, roll);
		log_append(src, short_tag + " already rolled?", 'message-server');
		return;
	}

	// does this roll match the die that we are expecting?
	const expected_which = roll[sock.id].which;
	if (which != expected_which)
	{
		log_append(src, short_tag + " wrong dice? expected " + expected_which + " got " + which, 'message-server');
		return;
	}

	roll[src] = { hash: BigInt("0x" + hash) };

	log_append(src, short_tag + " hashed " + hash , 'message-public');

	// if any peers have not yet commited to this tag, then we're done
	for (let peer in peers)
		if (!(peer in roll))
			return;

	// all peers have committed! time to reveal
	const my_value = roll[sock.id].value.toString(16);
	log_append(sock.id, short_tag + " reveal " + my_value);

	sock.emit('reveal', {
		"tag": tag,
		"which": which,
		"value": my_value,
	});
});

sock.on('reveal', (src,msg) => {
	console.log("reveal", src, msg);
	const tag = msg.tag;
	const which = msg.which;
	const value = msg.value;

	if (!(src in peers))
	{
		log_append(src, "not in peer group?" + msg, 'message-server');
		return;
	}

	if (!(tag in rolls))
	{
		log_append(src, tag.substr(0,16) + " not in rolls?" + msg, 'message-server');
		return;
	}

	const roll = rolls[tag];
	if (!(src in roll))
	{
		log_append(src, tag.substr(0,16) + " did not commit?" + msg, 'message-server');
		return;
	}

	const their_roll = roll[src];

	if ("value" in their_roll)
	{
		log_append(src, tag.substr(0,16) + " double reveal?" + msg, 'message-server');
		return;
	}

	const their_value = BigInt("0x" + value);
	const expected_hash = sha256BigInt(their_value);

	if (expected_hash != their_roll.hash)
	{
		console.log(src, "BAD HASH. Expected != Recieved", expected_hash.toString(16), their_roll.hash.toString(16));
		log_append(src, tag.substr(0,16) + " HASH CHEAT", 'message-server');
		return;
	}

	// looks good! accept it
	their_roll.value = their_value;
	log_append(src, tag.substr(0,16) + " reveal " + value);

	// try to compute the result of this roll
	// if any peers have not yet revealed this tag, then we're done
	let result = BigInt("0x" + tag);
	for (let peer in peers)
	{
		if (!(peer in roll))
			return;
		if (!("value" in roll[peer]))
			return;
		result += roll[peer].value; // already bigint
	}

	const choices = die[which].length;
	const short_result = result % BigInt(choices);
	const output = die[which][short_result];

	log_append(sock.id, tag.substr(0,16) + " VALUE=" + output);
	console.log("RESULT", tag, result, short_result, output);

	const d = document.getElementById("die-" + which);
	if (d)
		d.innerHTML = output;
});

</script>
</html>
